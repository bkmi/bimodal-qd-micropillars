%% Strong to strong feedback only in bimodal electric field.
% We investigate strong to strong feedback in the regime with weak
% dominating and strong dominating. 
%
% Weak dominating can be found with a turn-on time series given high enough
% current amplitude. Strong dominating can be found using a sweep up to the
% same current amplitude.
%
% In general, I did a single feedback amplitude continuation at zero phase.
% Then from there I branched off with four feedback phase branches. I
% followed the bifurcations along each of those branches. Since there are
% four feedback amplitude levels, I created packages: Folds with Weak Dom,
% Hopfs with Weak Dom, Folds with Strong Dom, Hopfs with Strong Dom.
%
% Each package is a cell which contains four levels of feedback amplitude.
% Each level has a structure which are the fold/hopf continuations of every
% bifurcation along that feedback phase branch at that particular amplitude
% given that particular configuration of strong or weak dom.

%
%
% The main idea is to get an overview of the bifurcation structure in each
% case.
%
%
%

%% General settings

clear;

% save location
datadir = strcat(data_directory(), '/str2strFB/');
while isdir(datadir) == 0;
    mkdir(datadir);
end

% Laser/FB settings
current = 560e-6;
fbAmp = 0.2;
fbPhase = 0;
alpha_par = 0;
tau_fb_par = 0.8;

% feedback matrix settings
feedAmpMat = [1, 0; 0, 0];
feedPhaseMat = [1, 1; 1, 1];

% bifurcation setup
aRot=...
    [0,-1,0,0,0;...
    1,0,0,0,0;...
    0,0,0,0,0;...
    0,0,0,0,0;...
    0,0,0,0,0];
expRot = @(phi)[...
    cos(phi),-sin(phi),0,0,0; ...
    sin(phi),cos(phi),0,0,0; ...
    0,0,1,0,0; ...
    0,0,0,1,0; ...
    0,0,0,0,1];
rhs = @(x,p)nonDim_bimodalINTENSITYSystem_CnstCplRatio( ...
    x(1,1,:) + 1i*x(2,1,:), x(1,2,:) + 1i*x(2,2,:),... % Es, EsTau
    x(3,1,:), x(3,2,:),... % Iw, IwTau
    x(4,1,:), ... % rho
    x(5,1,:), ... % n
    feedPhaseMat, feedAmpMat, ...
    p(1),p(2),p(3),p(4),p(5),p(6),p(7),p(8),p(9),p(10),p(11),...
    p(12),p(13),p(14),p(15),p(16),p(17),p(18),p(19),p(20),p(21),...
    p(22),p(23),p(24),p(25),p(26),p(27),p(28),p(29)); % Leave out omega
opt_inputs = {'extra_condition',1,'print_residual_info',0};
funcs = set_rotfuncs( ...
    'sys_rhs',rhs, ... 
    'rotation',aRot, ...
    'exp_rotation',expRot, ... 
    'sys_tau',@()bimodal_sys_tau, ...
    'x_vectorized',true);

save([datadir, ...
    'generalSettings.mat'], ...
    'datadir', ...
    'current', 'fbAmp', 'fbPhase','alpha_par', 'tau_fb_par', ...
    'feedAmpMat', 'feedPhaseMat', ...
    'aRot', 'expRot', 'rhs', 'opt_inputs', 'funcs')

%% Weak dominating, Time Series
% Using turn on time series, we can find the stable case where the weak
% field dominates the output of the laser.

% parameter setup
paramWeakDom = setup_params_nonDim_CnstCplRatio(...
    'save',0, ...
    'J', current, ...
    'feed_ampli',fbAmp, ...
    'feed_ampliMatrix', feedAmpMat, ...
    'feed_phase',fbPhase, ...
    'feed_phaseMatrix', feedPhaseMat, ...
    'tau_fb', tau_fb_par, ...
    'alpha_par',alpha_par, ...
    'clear',0,...
    'populate_wrkspc', 0);

% Turn On solver
systemWeakDom = @(x)nonDim_bimodalINTENSITYSystem_CnstCplRatio(...
    x(1,1,:) + 1i*x(2,1,:), x(1,2,:) + 1i*x(2,2,:),... % Es, EsTau
    x(3,1,:), x(3,2,:),... % Iw, IwTau
    x(4,1,:), ... % rho
    x(5,1,:), ... % n
    paramWeakDom.cplPar.feed_phaseMatrix, ...
    paramWeakDom.cplPar.feed_ampliMatrix, ...
    paramWeakDom.values(1),paramWeakDom.values(2), ...
    paramWeakDom.values(3),paramWeakDom.values(4), ...
    paramWeakDom.values(5),paramWeakDom.values(6), ...
    paramWeakDom.values(7),paramWeakDom.values(8), ...
    paramWeakDom.values(9),paramWeakDom.values(10), ...
    paramWeakDom.values(11),paramWeakDom.values(12), ...
    paramWeakDom.values(13),paramWeakDom.values(14), ...
    paramWeakDom.values(15),paramWeakDom.values(16), ...
    paramWeakDom.values(17),paramWeakDom.values(18), ...
    paramWeakDom.values(19),paramWeakDom.values(20), ...
    paramWeakDom.values(21),paramWeakDom.values(22), ...
    paramWeakDom.values(23),paramWeakDom.values(24), ...
    paramWeakDom.values(25),paramWeakDom.values(26), ...
    paramWeakDom.values(27),paramWeakDom.values(28), ...
    paramWeakDom.values(29)); % Leave out omega

lags = paramWeakDom.values(paramWeakDom.tau_fb.index);
hist = [1e-9, 0, 1e-9, 0, 0];
timeSpan = [0, 15];

timeSeriesWeakDom = dde23( ...
    @(t,y,z)systemWeakDom([y,z]),...
    lags,hist,timeSpan,ddeset('RelTol',10^-8)); % , 'OutputFcn', @odeplot



%% Weak dominating, Bifurcation Amplitude
% Now we will use the time series from above to explore the bifurcations in
% the weak dominating case.


stepBoundWeakDom = { ...
    'step',0.003, ...
    'max_step', ...
    [paramWeakDom.feed_ampli.index,0.006, ...
    paramWeakDom.omega1.index,0.1], ...
    'newton_max_iterations',10, ...
    'max_bound',[paramWeakDom.feed_ampli.index,2], ...
    'min_bound', [paramWeakDom.feed_ampli.index,-2], ...
    'halting_accuracy',1e-10, ...
    'minimal_accuracy',1e-8};

[branchStstWeakDom,~] = SetupStst( ...
    funcs, ...
    'contpar',[paramWeakDom.feed_ampli.index, paramWeakDom.omega1.index], ...
    'corpar',[paramWeakDom.omega1.index],...
    'x', timeSeriesWeakDom.y(:,end), ...
    'parameter',paramWeakDom.values(1:end-1),...
    opt_inputs{:},...
    stepBoundWeakDom{:});

% calculate
[branchStstWeakDom,~,~,~] = br_contn(funcs,branchStstWeakDom,60);
branchStstWeakDom = br_rvers(branchStstWeakDom);
[branchStstWeakDom,~,~,~] = br_contn(funcs,branchStstWeakDom,90);

% stability analysis
[branchStstWeakDom.nunst,~,~,branchStstWeakDom.point] = GetRotStability( ...
    branchStstWeakDom, ...
    funcs, 1);
branchStstWeakDom.indFold = find(abs(diff(branchStstWeakDom.nunst))==1);
branchStstWeakDom.indHopf = find(abs(diff(branchStstWeakDom.nunst))==2);
branchStstWeakDom.error = 0;


% Save Weak Dom
save([datadir, ...
    'weakDom.mat'], ...
    'paramWeakDom','systemWeakDom','timeSeriesWeakDom', ...
    'stepBoundWeakDom','branchStstWeakDom');


%% Weak dominating, Bifurcation Phase
% We make 4 "cuts" along the phase direction starting with the branch above
% where we followed amplitude. Given numPhaseBranches == 4, the cuts are at
% 2/6th, 3/6th, 4/6th, and 5/6th the point number of the amplitude branch.

% create container for phase stst branches
numPhaseBranches = 32;
pts4PhaseBranch = round( ...
    numel(branchStstWeakDom.point)/(numPhaseBranches+2) * ( (1:numPhaseBranches) + 1) );
branch_length = 800;

branchPhaseWeakDom = repmat( ...
    struct( ...
    'method', struct, ...
    'parameter', struct, ...
    'point', struct, ...
    'nunst', 0, ...
    'indFold', 0, ...
    'indHopf', 0, ...
    'error', 0),...
    [numPhaseBranches,1]);

stepBoundWeakDomPhase = { ...
    'step',pi/64, ...
    'max_step',...
    [paramWeakDom.feed_phase.index,pi/32, ...
    paramWeakDom.omega1.index,0.1], ...
    'newton_max_iterations',10, ...
    'max_bound',[paramWeakDom.feed_phase.index,10*pi], ...
    'min_bound', [paramWeakDom.feed_phase.index,-10*pi], ...
    'halting_accuracy',1e-10, ...
    'minimal_accuracy',1e-8};

for i = 1:numPhaseBranches
    [branchStstWeakDomPhase,~] = SetupStst( ...
        funcs, ...
        'contpar',[paramWeakDom.feed_phase.index, paramWeakDom.omega1.index], ...
        'corpar',[paramWeakDom.omega1.index],...
        'x', branchStstWeakDom.point(pts4PhaseBranch(i)).x, ...
        'parameter',branchStstWeakDom.point(pts4PhaseBranch(i)).parameter,...
        opt_inputs{:},...
        stepBoundWeakDomPhase{:});

    % calculate
    [branchStstWeakDomPhase,~,~,~] = br_contn(funcs,branchStstWeakDomPhase,branch_length);
    branchStstWeakDomPhase = br_rvers(branchStstWeakDomPhase);
    [branchStstWeakDomPhase,~,~,~] = br_contn(funcs,branchStstWeakDomPhase,branch_length);

    % stability analysis
    [branchStstWeakDomPhase.nunst,~,~,branchStstWeakDomPhase.point] = GetRotStability( ...
        branchStstWeakDomPhase, ...
        funcs, 1);
    branchStstWeakDomPhase.indFold = find(abs(diff(branchStstWeakDomPhase.nunst))==1);
    branchStstWeakDomPhase.indHopf = find(abs(diff(branchStstWeakDomPhase.nunst))==2);
    branchStstWeakDomPhase.error = 0;
    
    % add to 
    branchPhaseWeakDom(i,1) = branchStstWeakDomPhase;
    
end


% Save Weak Dom
save([datadir, ...
    'weakDom.mat'], ...
    'stepBoundWeakDomPhase', 'branchPhaseWeakDom', ...
    '-append');


%% Weak dominating, Additional Amplitude Bifurcations
% From the first phase branch, we make 4 "cuts" along the amplitude
% direction. Given numAmpBranches == 4 The cuts are at 2/6th, 3/6th,
% 4/6th, and 5/6th the point number of the phase branch.

% % create container for amp stst branches
% numAmpBranches = 4;
% branch_length = 150;
% 
% % Creates a package to hold a set of amp branches for each phase
% % branch.
% ampPkgWeakDom = cell(numPhaseBranches,1);
% 
% for j = 1:numPhaseBranches
%     
%     whichPhaseBranch = branchPhaseWeakDom(j,1);
%     pts4AmpBranch = round( ...
%         numel(whichPhaseBranch.point)/(numAmpBranches+2) * ( (1:numAmpBranches) + 1) );
%     
%     % create a amp branch for a particular phase branch.
%     branchAmpWeakDom = repmat( ...
%         struct( ...
%         'method', struct, ...
%         'parameter', struct, ...
%         'point', struct, ...
%         'nunst', 0, ...
%         'indFold', 0, ...
%         'indHopf', 0, ...
%         'error', 0),...
%         [numAmpBranches,1]);
% 
%     for i = 1:numAmpBranches
%         try
%             [branchStstWeakDomAmp,~] = SetupStst( ...
%                 funcs, ...
%                 'contpar',[paramWeakDom.feed_ampli.index, paramWeakDom.omega1.index], ...
%                 'corpar',[paramWeakDom.omega1.index],...
%                 'x', whichPhaseBranch.point(pts4AmpBranch(i)).x, ...
%                 'parameter',whichPhaseBranch.point(pts4AmpBranch(i)).parameter,...
%                 opt_inputs{:},...
%                 stepBoundWeakDom{:});
% 
%                 % calculate
%             [branchStstWeakDomAmp,~,~,~] = br_contn(funcs,branchStstWeakDomAmp,branch_length);
%             branchStstWeakDomAmp = br_rvers(branchStstWeakDomAmp);
%             [branchStstWeakDomAmp,~,~,~] = br_contn(funcs,branchStstWeakDomAmp,round(branch_length/4));
% 
%             % stability analysis
%             [branchStstWeakDomAmp.nunst,~,~,branchStstWeakDomAmp.point] = GetRotStability( ...
%                 branchStstWeakDomAmp, ...
%                 funcs, 1);
%             branchStstWeakDomAmp.indFold = find(abs(diff(branchStstWeakDomAmp.nunst))==1);
%             branchStstWeakDomAmp.indHopf = find(abs(diff(branchStstWeakDomAmp.nunst))==2);
%             branchStstWeakDomAmp.error = 0;
% 
%             % add to 
%             branchAmpWeakDom(i,1) = branchStstWeakDomAmp;
%         catch ME
%             switch ME.identifier
%                 case 'br_contn:start'
%                     fail = struct( ...
%                         'method', struct, ...
%                         'parameter', struct, ...
%                         'point', struct, ...
%                         'nunst', 0, ...
%                         'indFold', 0, ...
%                         'indHopf', 0, ...
%                         'error', 1);
%                     branchAmpWeakDom(i,1) = fail;
%                 case 'br_contn:fail'
%                     fail = struct( ...
%                         'method', struct, ...
%                         'parameter', struct, ...
%                         'point', struct, ...
%                         'nunst', 0, ...
%                         'indFold', 0, ...
%                         'indHopf', 0, ...
%                         'error', 1);
%                     branchAmpWeakDom(i,1) = fail;
%                 otherwise
%                     rethrow(ME)
%             end
% 
%         end
%     end
%     
%     %add to package
%     ampPkgWeakDom{j,1} = branchAmpWeakDom;
% end
% 
% 
% 
% 
% % Save Weak Dom
% save([datadir, ...
%     'weakDom.mat'], ...
%     'ampPkgWeakDom', ...
%     '-append');
% 

%% Weak dominating, Fold Continuations 
% Continuing the fold bifurcations from the lower bifurcations. The
% familiar angle.

stepBoundFoldWeak = { ...
    'step',0.05, ...
    'max_step', ...
    [paramWeakDom.feed_ampli.index,0.05, ...
    paramWeakDom.feed_phase.index,pi/32, ...
    paramWeakDom.omega1.index,0.1], ...
    'newton_max_iterations',10, ...
    'max_bound',[paramWeakDom.feed_ampli.index,2], ...
    'min_bound', [paramWeakDom.feed_ampli.index,-2], ...
    'halting_accuracy',1e-10, ...
    'minimal_accuracy',1e-8};

% this container holds each set of continuations from each phase branch.
foldPkgWeakDom = cell(numPhaseBranches,1);

for j = 1:numel(foldPkgWeakDom)
    
    % prepare pts to continue
    pickBranch = branchPhaseWeakDom(j,1); % input branch to analyse
    ptsFoldsWeakDom = 1:numel(pickBranch.indFold); % select points by index of index
    
    foldsWeakDom = repmat( ...
        orderfields(...
        struct( ...
        'method', struct, ...
        'parameter', struct, ...
        'point', struct, ...
        'nunst', 0, ...
        'indFold', 0, ...
        'indHopf', 0, ...
        'error', 0)),...
        [numel(ptsFoldsWeakDom),1]);

    for i = 1:numel(ptsFoldsWeakDom)

        try
            [foldfuncs,foldWeak,~]=SetupRWFold( ...
                funcs, ...
                pickBranch, ...
                pickBranch.indFold(ptsFoldsWeakDom(i)),...
                'contpar', ...
                [paramWeakDom.feed_phase.index, ...
                paramWeakDom.feed_ampli.index, ...
                paramWeakDom.omega1.index], ...
                'dir',paramWeakDom.feed_ampli.index, ...
                opt_inputs{:},...
                stepBoundFoldWeak{:}); 

            foldBranchLength = 150;

            foldWeak = br_contn(foldfuncs,foldWeak,foldBranchLength);
            foldWeak = br_rvers(foldWeak);
            foldWeak = br_contn(foldfuncs,foldWeak,foldBranchLength);
            foldWeak.error = 0;

            foldsWeakDom(i,1) = orderfields(foldWeak);
        catch ME
            switch ME.identifier
                case 'br_contn:start'
                    foldWeak = struct( ...
                        'method', struct, ...
                        'parameter', struct, ...
                        'point', struct, ...
                        'nunst', 0, ...
                        'indFold', 0, ...
                        'indHopf', 0, ...
                        'error', 1);
                    foldsWeakDom(i,1) = orderfields(foldWeak);
                case 'br_contn:fail'
                    foldWeak = struct( ...
                        'method', struct, ...
                        'parameter', struct, ...
                        'point', struct, ...
                        'nunst', 0, ...
                        'indFold', 0, ...
                        'indHopf', 0, ...
                        'error', 1);
                    foldsWeakDom(i,1) = orderfields(foldWeak);
                otherwise
                    rethrow(ME)
            end

        end
    end
    
    foldPkgWeakDom{j,1} = foldsWeakDom;
    
end


% Save Weak Dom
save([datadir, ...
    'weakDom.mat'], ...
    'stepBoundFoldWeak', 'foldPkgWeakDom', ...
    '-append');



%% Weak dominating, Hopf Continuations 
% Continuing the hopf bifurcations.

stepBoundHopfWeak = { ...
    'step',0.05, ...
    'max_step', ...
    [paramWeakDom.feed_ampli.index,0.1, ...
    paramWeakDom.feed_phase.index,pi/8, ...
    paramWeakDom.omega1.index,0.1], ...
    'newton_max_iterations',10, ...
    'max_bound',[paramWeakDom.feed_ampli.index,2], ...
    'min_bound', [paramWeakDom.feed_ampli.index,-2], ...
    'halting_accuracy',1e-10, ...
    'minimal_accuracy',1e-8};

% this container holds each set of continuations from each phase branch.
hopfPkgWeakDom = cell(numPhaseBranches,1);

for j = 1:numel(hopfPkgWeakDom)
    % prepare pts to continue
    pickBranch = branchPhaseWeakDom(j,1); % input branch to analyse
    ptsHopfsWeakDom = 1:numel(pickBranch.indHopf); % select points by index of index

    disp(j)
    disp(pickBranch)
    
    hopfsWeakDom = repmat( ...
        orderfields(...
        struct( ...
        'method', struct, ...
        'parameter', struct, ...
        'point', struct, ...
        'nunst', 0, ...
        'indFold', 0, ...
        'indHopf', 0, ...
        'error', 0)),...
        [numel(ptsHopfsWeakDom),1]);

    for i = 1:numel(ptsHopfsWeakDom)
        try
            [hopfOne,~]=SetupRWHopf( ...
                funcs, ...
                pickBranch, ...
                pickBranch.indHopf(ptsHopfsWeakDom(i)), ...
                'contpar', ...
                [paramWeakDom.feed_phase.index, ...
                paramWeakDom.feed_ampli.index, ...
                paramWeakDom.omega1.index], ...
                'dir',paramWeakDom.feed_phase.index, ...
                opt_inputs{:},...
                stepBoundHopfWeak{:});

            hopfBranchLength = 250;

            [hopfOne,~,~,~] = br_contn(funcs,hopfOne,hopfBranchLength);
            hopfOne = br_rvers(hopfOne);
            hopfOne = br_contn(funcs,hopfOne,hopfBranchLength);

            hopfsWeakDom(i,1) = orderfields(hopfOne);
        catch ME
            switch ME.identifier
                case 'br_contn:start'
                    hopfOne = struct( ...
                        'method', struct, ...
                        'parameter', struct, ...
                        'point', struct, ...
                        'nunst', 0, ...
                        'indFold', 0, ...
                        'indHopf', 0, ...
                        'error', 1);
                    hopfsWeakDom(i,1) = orderfields(hopfOne);
                case 'br_contn:fail'
                    hopfOne = struct( ...
                        'method', struct, ...
                        'parameter', struct, ...
                        'point', struct, ...
                        'nunst', 0, ...
                        'indFold', 0, ...
                        'indHopf', 0, ...
                        'error', 1);
                    hopfsWeakDom(i,1) = orderfields(hopfOne);
                otherwise
                    rethrow(ME)
            end

        end
    end
    
    hopfPkgWeakDom{j} = hopfsWeakDom;
    
end


% Save Weak Dom
save([datadir, ...
    'weakDom.mat'], ...
    'stepBoundHopfWeak', 'hopfPkgWeakDom', ...
    '-append');


%% Strong dominating
% You can find this time series by sweeping up, but I am too lasy to write
% a sweep program for this system. Instead, I'm going to guess a history
% which might get me into the regime with the strong field dominating.

paramStrDom = setup_params_nonDim_CnstCplRatio(...
    'save',0, ...
    'J', current, ...
    'feed_ampli',fbAmp, ...
    'feed_ampliMatrix', feedAmpMat, ...
    'feed_phase',fbPhase, ...
    'feed_phaseMatrix', feedPhaseMat, ...
    'tau_fb', tau_fb_par, ...
    'alpha_par',alpha_par, ...
    'clear',0,...
    'populate_wrkspc', 0);

% Turn On solver
systemStrDom = @(x)nonDim_bimodalINTENSITYSystem_CnstCplRatio(...
    x(1,1,:) + 1i*x(2,1,:), x(1,2,:) + 1i*x(2,2,:),... % Es, EsTau
    x(3,1,:), x(3,2,:),... % Iw, IwTau
    x(4,1,:), ... % rho
    x(5,1,:), ... % n
    paramStrDom.cplPar.feed_phaseMatrix, ...
    paramStrDom.cplPar.feed_ampliMatrix, ...
    paramStrDom.values(1),paramStrDom.values(2), ...
    paramStrDom.values(3),paramStrDom.values(4), ...
    paramStrDom.values(5),paramStrDom.values(6), ...
    paramStrDom.values(7),paramStrDom.values(8), ...
    paramStrDom.values(9),paramStrDom.values(10), ...
    paramStrDom.values(11),paramStrDom.values(12), ...
    paramStrDom.values(13),paramStrDom.values(14), ...
    paramStrDom.values(15),paramStrDom.values(16), ...
    paramStrDom.values(17),paramStrDom.values(18), ...
    paramStrDom.values(19),paramStrDom.values(20), ...
    paramStrDom.values(21),paramStrDom.values(22), ...
    paramStrDom.values(23),paramStrDom.values(24), ...
    paramStrDom.values(25),paramStrDom.values(26), ...
    paramStrDom.values(27),paramStrDom.values(28), ...
    paramStrDom.values(29)); % Leave out omega

lags = paramStrDom.values(paramStrDom.tau_fb.index);
hist = [0.9^2, 0, 0.01, 0.6, 14];
timeSpan = [0, 15];

timeSeriesStrDom = dde23( ...
    @(t,y,z)systemStrDom([y,z]),...
    lags,hist,timeSpan,ddeset('RelTol',10^-8)); % , 'OutputFcn', @odeplot

%% Strong dominating, Bifurcation
% Now we will use the time series from above to explore the bifurcations in
% the strong dominating case.
branch_length = 120;

stepBoundStrDom = {'step',0.009, ...
    'max_step', ...
    [paramStrDom.feed_ampli.index,0.006, ...
    paramWeakDom.omega1.index,0.1], ...
    'newton_max_iterations',10, ...
    'max_bound',[paramStrDom.feed_ampli.index,2], ...
    'min_bound', [paramStrDom.feed_ampli.index,-2], ...
    'halting_accuracy',1e-10, ...
    'minimal_accuracy',1e-8};

[branchStstStrDom,~]=SetupStst(funcs, ...
    'contpar',[paramStrDom.feed_ampli.index, paramStrDom.omega1.index], ...
    'corpar',[paramStrDom.omega1.index],...
    'x', timeSeriesStrDom.y(:,end), ...
    'parameter',paramStrDom.values(1:end-1),...
    opt_inputs{:},...
    stepBoundStrDom{:});

% calculate
[branchStstStrDom,~,~,~] = br_contn(funcs,branchStstStrDom,branch_length);
branchStstStrDom = br_rvers(branchStstStrDom);
[branchStstStrDom,~,~,~] = br_contn(funcs,branchStstStrDom,round(branch_length/4));

% stability analysis
[branchStstStrDom.nunst,~,~,branchStstStrDom.point] = GetRotStability(...
    branchStstStrDom, ...
    funcs, 1);
branchStstStrDom.indFold = find(abs(diff(branchStstStrDom.nunst))==1);
branchStstStrDom.indHopf = find(abs(diff(branchStstStrDom.nunst))==2);
branchStstStrDom.error = 0;


% Save Strong Dom
save([datadir, ...
    'strongDom.mat'], ...
    'paramStrDom','systemStrDom','timeSeriesStrDom', ...
    'stepBoundStrDom','branchStstStrDom');


%% Strong dominating, Bifurcation Phase
% We make 4 "cuts" along the phase direction starting with the branch above
% where we followed amplitude. The cuts are at 2/6th, 3/6th, 4/6th, and
% 5/6th the point number of the amplitude branch.

% create container for phase stst branches
numPhaseBranches = 32;
pts4PhaseBranch = round( ...
    numel(branchStstStrDom.point)/(numPhaseBranches+2) * ( (1:numPhaseBranches) + 1) );
branch_length = 800;

branchPhaseStrDom = repmat( ...
    struct( ...
    'method', struct, ...
    'parameter', struct, ...
    'point', struct, ...
    'nunst', 0, ...
    'indFold', 0, ...
    'indHopf', 0, ...
    'error', 0),...
    [numPhaseBranches,1]);

stepBoundStrDomPhase = { ...
    'step',pi/32, ...
    'max_step', ...
    [paramStrDom.feed_phase.index,pi/32, ...
    paramWeakDom.omega1.index,0.1], ...
    'newton_max_iterations',10, ...
    'max_bound',[paramStrDom.feed_phase.index,20*pi], ...
    'min_bound', [paramStrDom.feed_phase.index,-20*pi], ...
    'halting_accuracy',1e-10, ...
    'minimal_accuracy',1e-8};

for i = 1:numPhaseBranches
    [branchStstStrDomPhase,~] = SetupStst( ...
        funcs, ...
        'contpar',[paramStrDom.feed_phase.index, paramStrDom.omega1.index], ...
        'corpar',[paramStrDom.omega1.index],...
        'x', branchStstStrDom.point(pts4PhaseBranch(i)).x, ...
        'parameter',branchStstStrDom.point(pts4PhaseBranch(i)).parameter,...
        opt_inputs{:},...
        stepBoundStrDomPhase{:});

    % calculate
    [branchStstStrDomPhase,~,~,~] = br_contn(funcs,branchStstStrDomPhase,branch_length);
    branchStstStrDomPhase = br_rvers(branchStstStrDomPhase);
    [branchStstStrDomPhase,~,~,~] = br_contn(funcs,branchStstStrDomPhase,branch_length);

    % stability analysis
    [branchStstStrDomPhase.nunst,~,~,branchStstStrDomPhase.point] = GetRotStability( ...
        branchStstStrDomPhase, ...
        funcs, 1);
    branchStstStrDomPhase.indFold = find(abs(diff(branchStstStrDomPhase.nunst))==1);
    branchStstStrDomPhase.indHopf = find(abs(diff(branchStstStrDomPhase.nunst))==2);
    branchStstStrDomPhase.error = 0;
    
    % add to 
    branchPhaseStrDom(i,1) = branchStstStrDomPhase;
    
end


% Save Strong Dom
save([datadir, ...
    'strongDom.mat'], ...
    'stepBoundStrDomPhase', 'branchPhaseStrDom', ...
    '-append');

%% Strong dominating, Additional Amplitude Bifurcations
% From the first phase branch, we make 4 "cuts" along the amplitude
% direction. Given numAmpBranches == 4 The cuts are at 2/6th, 3/6th,
% 4/6th, and 5/6th the point number of the phase branch.

% % create container for amp stst branches
% numAmpBranches = 4;
% branch_length = 150;
% 
% % Creates a package to hold a set of amp branches for each phase
% % branch.
% ampPkgStrDom = cell(numPhaseBranches,1);
% 
% for j = 1:numPhaseBranches
%     whichPhaseBranch = branchPhaseStrDom(j,1);
%     pts4AmpBranch = round( ...
%         numel(whichPhaseBranch.point)/(numAmpBranches+2) * ( (1:numAmpBranches) + 1) );
%     
%     % This is where a set of branches are created.
%     branchAmpStrDom = repmat( ...
%         struct( ...
%         'method', struct, ...
%         'parameter', struct, ...
%         'point', struct, ...
%         'nunst', 0, ...
%         'indFold', 0, ...
%         'indHopf', 0, ...
%         'error', 0),...
%         [numAmpBranches,1]);
% 
%     for i = 1:numAmpBranches
%         try
%             [branchStstStrDomAmp,~] = SetupStst( ...
%                 funcs, ...
%                 'contpar',[paramStrDom.feed_ampli.index, paramStrDom.omega1.index], ...
%                 'corpar',[paramStrDom.omega1.index],...
%                 'x', whichPhaseBranch.point(pts4AmpBranch(i)).x, ...
%                 'parameter',whichPhaseBranch.point(pts4AmpBranch(i)).parameter,...
%                 opt_inputs{:},...
%                 stepBoundStrDom{:});
% 
%                 % calculate
%             [branchStstStrDomAmp,~,~,~] = br_contn(funcs,branchStstStrDomAmp,branch_length);
%             branchStstStrDomAmp = br_rvers(branchStstStrDomAmp);
%             [branchStstStrDomAmp,~,~,~] = br_contn(funcs,branchStstStrDomAmp,round(branch_length/4));
% 
%             % stability analysis
%             [branchStstStrDomAmp.nunst,~,~,branchStstStrDomAmp.point] = GetRotStability( ...
%                 branchStstStrDomAmp, ...
%                 funcs, 1);
%             branchStstStrDomAmp.indFold = find(abs(diff(branchStstStrDomAmp.nunst))==1);
%             branchStstStrDomAmp.indHopf = find(abs(diff(branchStstStrDomAmp.nunst))==2);
%             branchStstStrDomAmp.error = 0;
% 
%             % add to 
%             branchAmpStrDom(i,1) = branchStstStrDomAmp;
%         catch ME
%             switch ME.identifier
%                 case 'br_contn:start'
%                     fail = struct( ...
%                         'method', struct, ...
%                         'parameter', struct, ...
%                         'point', struct, ...
%                         'nunst', 0, ...
%                         'indFold', 0, ...
%                         'indHopf', 0, ...
%                         'error', 1);
%                     branchAmpStrDom(i,1) = fail;
%                 case 'br_contn:fail'
%                     fail = struct( ...
%                         'method', struct, ...
%                         'parameter', struct, ...
%                         'point', struct, ...
%                         'nunst', 0, ...
%                         'indFold', 0, ...
%                         'indHopf', 0, ...
%                         'error', 1);
%                     branchAmpStrDom(i,1) = fail;
%                 otherwise
%                     rethrow(ME)
%             end
% 
%         end
%     end
%     
%     % add to package
%     ampPkgStrDom{j,1} = branchAmpStrDom;
% end
% 
% 
% 
% 
% % Save Strong Dom
% save([datadir, ...
%     'strongDom.mat'], ...
%     'ampPkgStrDom', ...
%     '-append');


%% Strong dominating, Fold Continuations 
% Continuing the fold bifurcations from the lower bifurcations. The
% familiar angle.

stepBoundFoldStr = { ...
    'step',0.05, ...
    'max_step', ...
    [paramStrDom.feed_ampli.index,0.05, ...
    paramStrDom.feed_phase.index,pi/32, ...
    paramWeakDom.omega1.index,0.1], ...
    'newton_max_iterations',10, ...
    'max_bound',[paramStrDom.feed_ampli.index,2], ...
    'min_bound', [paramStrDom.feed_ampli.index,-2], ...
    'halting_accuracy',1e-10, ...
    'minimal_accuracy',1e-8};

% this container holds each set of continuations from each phase branch.
foldPkgStrDom = cell(numPhaseBranches,1);

for j = 1:numel(foldPkgStrDom)

    % prepare pts to continue
    pickBranch = branchPhaseStrDom(j,1); % input branch to analyse
    ptsFoldsStrDom = 1:numel(pickBranch.indFold); % select points by index of index
    
    foldsStrDom = repmat( ...
        orderfields(...
        struct( ...
        'method', struct, ...
        'parameter', struct, ...
        'point', struct, ...
        'nunst', 0, ...
        'indFold', 0, ...
        'indHopf', 0, ...
        'error', 0)),...
        [numel(ptsFoldsStrDom),1]);

    for i = 1:numel(ptsFoldsStrDom)
        try
            [foldfuncs,foldStr,~]=SetupRWFold( ...
                funcs, ...
                pickBranch, ...
                pickBranch.indFold(ptsFoldsStrDom(i)),...
                'contpar', ...
                [paramStrDom.feed_phase.index, ...
                paramStrDom.feed_ampli.index, ...
                paramStrDom.omega1.index], ...
                'dir',paramStrDom.feed_ampli.index, ...
                opt_inputs{:},...
                stepBoundFoldStr{:}); 

            foldBranchLength = 2;

            foldStr = br_contn(foldfuncs,foldStr,foldBranchLength);
            foldStr = br_rvers(foldStr);
            foldStr = br_contn(foldfuncs,foldStr,foldBranchLength);
            foldStr.error = 0;
            
            foldsStrDom(i,1) = orderfields(foldStr);
            
        catch ME
            switch ME.identifier
                case 'br_contn:start'
                    foldStr = struct( ...
                        'method', struct, ...
                        'parameter', struct, ...
                        'point', struct, ...
                        'nunst', 0, ...
                        'indFold', 0, ...
                        'indHopf', 0, ...
                        'error', 1);
                    foldsStrDom(i,1) = orderfields(foldStr);
                otherwise
                    rethrow(ME)
            end

        end
    end
    
    foldPkgStrDom{j,1} = foldsStrDom;
    
end


% Save Strong Dom
save([datadir, ...
    'strongDom.mat'], ...
    'stepBoundFoldStr', 'foldPkgStrDom', ...
    '-append');


%% Strong dominating, Hopf Continuations 
% Continuing the hopf bifurcations.
%

stepBoundHopfStr = { ...
    'step',0.05, ...
    'max_step', ...
    [paramStrDom.feed_ampli.index,0.05, ...
    paramStrDom.feed_phase.index,pi/32, ...
    paramWeakDom.omega1.index,0.1], ...
    'newton_max_iterations',10, ...
    'max_bound',[paramStrDom.feed_ampli.index,2], ...
    'min_bound', [paramStrDom.feed_ampli.index,-2], ...
    'halting_accuracy',1e-10, ...
    'minimal_accuracy',1e-8};


% this container holds each set of continuations from each phase branch.
hopfPkgStrDom = cell(numPhaseBranches,1);


for j = 1:numel(hopfPkgStrDom)
    % prepare pts to continue
    pickBranch = branchPhaseStrDom(j,1); % input branch to analyse
    ptsHopfsStrDom = 1:numel(pickBranch.indHopf); % select points by index of index

    disp(j)
    disp(pickBranch)
    
    hopfsStrDom = repmat( ...
        orderfields(...
        struct( ...
        'method', struct, ...
        'parameter', struct, ...
        'point', struct, ...
        'nunst', 0, ...
        'indFold', 0, ...
        'indHopf', 0, ...
        'error', 0)),...
        [numel(ptsHopfsStrDom),1]);

    for i = 1:numel(ptsHopfsStrDom)
        try
            [hopfOne,~]=SetupRWHopf( ...
                funcs, ...
                pickBranch, ...
                pickBranch.indHopf(ptsHopfsStrDom(i)), ...
                'contpar', ...
                [paramStrDom.feed_phase.index, ...
                paramStrDom.feed_ampli.index, ...
                paramStrDom.omega1.index], ...
                'dir',paramStrDom.feed_phase.index, ...
                opt_inputs{:},...
                stepBoundHopfStr{:});

            hopfBranchLength = 100;

            [hopfOne,~,~,~] = br_contn(funcs,hopfOne,hopfBranchLength);
            hopfOne = br_rvers(hopfOne);
            hopfOne = br_contn(funcs,hopfOne,hopfBranchLength);
            hopfOne.error = 0;

            hopfsStrDom(i,1) = orderfields(hopfOne);

        catch ME
            switch ME.identifier
                case 'br_contn:start'
                    hopfOne = struct( ...
                        'method', struct, ...
                        'parameter', struct, ...
                        'point', struct, ...
                        'nunst', 0, ...
                        'indFold', 0, ...
                        'indHopf', 0, ...
                        'error', 1);
                    hopfsStrDom(i,1) = orderfields(hopfOne);
                case 'br_contn:fail'
                    hopfOne = struct( ...
                        'method', struct, ...
                        'parameter', struct, ...
                        'point', struct, ...
                        'nunst', 0, ...
                        'indFold', 0, ...
                        'indHopf', 0, ...
                        'error', 1);
                    hopfsStrDom(i,1) = orderfields(hopfOne);
                otherwise
                    rethrow(ME)
            end

        end
    end
    
    hopfPkgStrDom{j} = hopfsStrDom;
    
end


% Save Strong Dom
save([datadir, ...
    'strongDom.mat'], ...
    'stepBoundHopfStr', 'hopfPkgStrDom', ...
    '-append');


%% BASIC PLOT
% 
% % str
% ok = figure('color','w');
% for i = 1:numel(hopfPkgStrDom)
%     for j = 1:numel(hopfPkgStrDom{i,1})
%         plotIT = hopfPkgStrDom{i,1};
%         if plotIT(j).error == 0;
%             plot_branch(plotIT(j),paramStrDom,'add_2_gcf',1, ...
%                 'PlotStyle',{ 'LineStyle', '-', 'Marker', '.' });
%         end
%     end
% end
% 
% for i = 1:numel(foldPkgStrDom)
%     for j = 1:numel(foldPkgStrDom{i,1})
%         plotIT = foldPkgStrDom{i,1};
%         if plotIT(j).error == 0;
%             plot_branch(plotIT(j),paramStrDom,'add_2_gcf',1,'color','r', ...
%                 'PlotStyle',{ 'LineStyle', '-', 'Marker', '.' } );
%         end
%     end
% end
% 
% set(ok,'PaperType','a4')
% set(ok,'PaperOrientation','landscape');
% set(ok,'PaperUnits','normalized');
% set(ok,'PaperPosition', [0 0 1 1]);
% 
% ylim([0,1])
% 
% okName = [datadir, 'strDom','.pdf'];
% print(ok, ...
%     okName, ...
%     '-dpdf')

% % weak
% figure
% for i = 1:numel(hopfPkgWeakDom)
%     for j = 1:numel(hopfPkgWeakDom{i,1})
%         plotIT = hopfPkgWeakDom{i,1};
%         if plotIT(j).error == 0;
%             plot_branch(plotIT(j),paramStrDom,'add_2_gcf',1, ...
%                 'PlotStyle',{ 'LineStyle', '-', 'Marker', '.' });
%         end
%     end
% end
% 
% for i = 1:numel(foldPkgWeakDom)
%     for j = 1:numel(foldPkgWeakDom{i,1})
%         plotIT = foldPkgWeakDom{i,1};
%         if plotIT(j).error == 0;
%             plot_branch(plotIT(j),paramStrDom,'add_2_gcf',1,'color','r', ...
%                 'PlotStyle',{ 'LineStyle', '-', 'Marker', '.' } );
%         end
%     end
% end

%% 3D PLOT strong dom

figure();

% only the destabilzing bifurcations
for i = 1:numel(hopfPkgStrDom)
    % select the ones that destablize the branch
    [~,destabFold,destabHopf] = destabilize_finder(branchPhaseStrDom(i,1).nunst);
    
    if numel(destabHopf) ~= 0 && max(destabHopf) <= numel(hopfPkgStrDom{i})
        disp('yep')
        for j = destabHopf' % 1:numel(hopfPkgStrDom{i})
            if hopfPkgStrDom{i}(j,1).error == 0
                plot_branch3(hopfPkgStrDom{i}(j,1), paramStrDom, ...
                    'add_2_gcf',1, ...
                    'color', 'cyan', ...
                    'axes_indParam', ...
                    {hopfPkgStrDom{i}(j,1).parameter.free(1), ...
                    hopfPkgStrDom{i}(j,1).parameter.free(2), ...
                    'x1'}, ...
                    'PlotStyle', { 'LineStyle', '-', 'Marker', '.' } );
            end
        end
    end
    
    if numel(destabFold) ~= 0 && max(destabFold) <= numel(foldPkgStrDom{i})
        for j = destabFold' % 1:numel(foldPkgStrDom{i})
            if foldPkgStrDom{i}(j,1).error == 0
                plot_branch3(foldPkgStrDom{i}(j,1), paramStrDom, ...
                    'add_2_gcf',1, ...
                    'color', 'r', ...
                    'axes_indParam', ...
                    {foldPkgStrDom{i}(j,1).parameter.free(1), ...
                    foldPkgStrDom{i}(j,1).parameter.free(2), ...
                    'x1'}, ...
                    'PlotStyle', { 'LineStyle', '-', 'Marker', '.' } );
            end
        end
    end
    
end

% % All hopfs and folds
% for i = 1:numel(hopfPkgStrDom)
%     for j = 1:numel(hopfPkgStrDom{i})
%         if hopfPkgStrDom{i}(j,1).error == 0
%             plot_branch3(hopfPkgStrDom{i}(j,1), paramStrDom, ...
%                 'add_2_gcf',1, ...
%                 'color', 'cyan', ...
%                 'axes_indParam', ...
%                 {hopfPkgStrDom{i}(j,1).parameter.free(1), ...
%                 hopfPkgStrDom{i}(j,1).parameter.free(2), ...
%                 'x1'}, ...
%                 'PlotStyle', { 'LineStyle', '-', 'Marker', '.' } );
%         end
%     end
%     
%     for j = 1:numel(foldPkgStrDom{i})
%         if foldPkgStrDom{i}(j,1).error == 0
%             plot_branch3(foldPkgStrDom{i}(j,1), paramStrDom, ...
%                 'add_2_gcf',1, ...
%                 'color', 'r', ...
%                 'axes_indParam', ...
%                 {foldPkgStrDom{i}(j,1).parameter.free(1), ...
%                 foldPkgStrDom{i}(j,1).parameter.free(2), ...
%                 'x1'}, ...
%                 'PlotStyle', { 'LineStyle', '-', 'Marker', '.' } );
%         end
%     end
%     
% end

% find highest nunst
globalmax = 0;
for i = 1: numel(branchPhaseStrDom)
    localmax = max(branchPhaseStrDom(i,1).nunst);
    if localmax > globalmax
        globalmax = localmax;
    end
end
for j = 1:numel(ampPkgStrDom)
    branchAmpStrDom = ampPkgStrDom{j,1};
    for i = 1: numel(branchAmpStrDom)
        localmax = max(branchAmpStrDom(i,1).nunst);
        if localmax > globalmax
            globalmax = localmax;
        end
    end
end
for i = 1: numel(branchStstStrDom)
    localmax = max(branchStstStrDom(i,1).nunst);
    if localmax > globalmax
        globalmax = localmax;
    end
end

% ribs
for i = numel(branchPhaseStrDom):-1:1
    plot_branch3(branchPhaseStrDom(i,1), paramStrDom, ...
        'nunst_color',{branchPhaseStrDom(i,1).nunst, 6}, ... % globalmax}, ...
        'add_2_gcf',1, ...
        'axes_indParam', ...
        {paramStrDom.feed_phase.index, ...
        paramStrDom.feed_ampli.index, ...
        'x1'}, ...
        'PlotStyle', { 'LineStyle', 'None', 'Marker', '.' } );
end

% main spine
cutBranch = branchStstStrDom;
cutBranch.point(1:50) = [];
cutBranch.nunst(1:50) = [];

plot_branch3(cutBranch, paramStrDom, ...
    'nunst_color',{cutBranch.nunst, 6}, ... % globalmax}, ...
    'add_2_gcf',1, ...
    'axes_indParam', ...
    {paramStrDom.feed_phase.index, ...
    paramStrDom.feed_ampli.index, ...
    'x1'}, ...
    'PlotStyle', { 'LineStyle', '-', 'Marker', '.' } );

% extra spines
for j = 1:numel(ampPkgStrDom)
    
    branchAmpStrDom = ampPkgStrDom{j,1};
    
    % extra spines
    for i = 1:numel(branchAmpStrDom)
        
        if branchAmpStrDom(i,1).error == 1;
            continue
        end
        
        plot_branch3(branchAmpStrDom(i,1), paramWeakDom, ...
            'nunst_color',{branchAmpStrDom(i,1).nunst, 6}, ... % globalmax}, ...
            'add_2_gcf',1, ...
            'axes_indParam', ...
            {paramWeakDom.feed_phase.index, ...
            paramWeakDom.feed_ampli.index, ...
            'x1'}, ...
            'PlotStyle', { 'LineStyle', 'None', 'Marker', '.' } );
    end
end

ylim([0,1])
zlim([0,3])

%% 3d weak dom

figure();

% hopfs and folds
for i = 1:numel(hopfPkgWeakDom)
    for j = 1:numel(hopfPkgWeakDom{i})
        if hopfPkgWeakDom{i}(j,1).error == 0
            plot_branch3(hopfPkgWeakDom{i}(j,1), paramWeakDom, ...
                'add_2_gcf',1, ...
                'color', 'cyan', ...
                'axes_indParam', ...
                {hopfPkgWeakDom{i}(j,1).parameter.free(1), ...
                hopfPkgWeakDom{i}(j,1).parameter.free(2), ...
                'x1'}, ...
                'PlotStyle', { 'LineStyle', '-', 'Marker', '.' } );
        end
    end
    
    for j = 1:numel(foldPkgWeakDom{i})
        if foldPkgWeakDom{i}(j,1).error == 0
            plot_branch3(foldPkgWeakDom{i}(j,1), paramWeakDom, ...
                'add_2_gcf',1, ...
                'color', 'r', ...
                'axes_indParam', ...
                {foldPkgWeakDom{i}(j,1).parameter.free(1), ...
                foldPkgWeakDom{i}(j,1).parameter.free(2), ...
                'x1'}, ...
                'PlotStyle', { 'LineStyle', '-', 'Marker', '.' } );
        end
    end
    
end

% find highest nunst
localmax = 0;
globalmax = 0;
for i = 1: numel(branchPhaseWeakDom)
    localmax = max(branchPhaseWeakDom(i,1).nunst);
    if localmax > globalmax
        globalmax = localmax;
    end
end
for j = 1:numel(ampPkgWeakDom)
    
    branchAmpWeakDom = ampPkgWeakDom{j,1};
    
    for i = 1: numel(branchAmpWeakDom)
        localmax = max(branchAmpWeakDom(i,1).nunst);
        if localmax > globalmax
            globalmax = localmax;
        end
    end
end
for i = 1: numel(branchStstWeakDom)
    localmax = max(branchStstWeakDom(i,1).nunst);
    if localmax > globalmax
        globalmax = localmax;
    end
end

% main spine
cutBranch = branchStstWeakDom;
cutBranch.point(1:50) = [];
cutBranch.nunst(1:50) = [];

plot_branch3(cutBranch, paramWeakDom, ...
    'nunst_color',{cutBranch.nunst, 6}, ... % globalmax}, ...
    'add_2_gcf',1, ...
    'axes_indParam', ...
    {paramWeakDom.feed_phase.index, ...
    paramWeakDom.feed_ampli.index, ...
    'x1'}, ...
    'PlotStyle', { 'LineStyle', '-', 'Marker', '.' } );

% extra spines
for j = 1:numel(ampPkgWeakDom)
    
    branchAmpWeakDom = ampPkgWeakDom{j,1};
    
    for i = 1:numel(branchAmpWeakDom)
        plot_branch3(branchAmpWeakDom(i,1), paramWeakDom, ...
            'nunst_color',{branchAmpWeakDom(i,1).nunst, 6}, ... % globalmax}, ...
            'add_2_gcf',1, ...
            'axes_indParam', ...
            {paramWeakDom.feed_phase.index, ...
            paramWeakDom.feed_ampli.index, ...
            'x1'}, ...
            'PlotStyle', { 'LineStyle', 'None', 'Marker', '.' } );
    end
end

for i = 1:numel(branchAmpWeakDom)
    plot_branch3(branchAmpWeakDom(i,1), paramWeakDom, ...
        'nunst_color',{branchAmpWeakDom(i,1).nunst, 6}, ... % globalmax}, ...
        'add_2_gcf',1, ...
        'axes_indParam', ...
        {paramWeakDom.feed_phase.index, ...
        paramWeakDom.feed_ampli.index, ...
        'x1'}, ...
        'PlotStyle', { 'LineStyle', 'None', 'Marker', '.' } );
end

% ribs
for i = numel(branchPhaseWeakDom):-1:1
    plot_branch3(branchPhaseWeakDom(i,1), paramWeakDom, ...
        'nunst_color',{branchPhaseWeakDom(i,1).nunst, 6}, ... % globalmax}, ...
        'add_2_gcf',1, ...
        'axes_indParam', ...
        {paramWeakDom.feed_phase.index, ...
        paramWeakDom.feed_ampli.index, ...
        'x1'}, ...
        'PlotStyle', { 'LineStyle', 'None', 'Marker', '.' } );
end

% ylim([0,0.6])
zlim([0,0.6])









