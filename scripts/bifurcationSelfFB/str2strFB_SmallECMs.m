%% Strong to strong feedback only in bimodal electric field - ECM investigation
% Create a ton of "ribs" aka phase continuations in the region where ecms
% go unstable in a fold bifurcation to see the "tubes" get bigger.


clear;

% save location
datadir = strcat(data_directory(), '/str2strFB/');
while isdir(datadir) == 0;
    mkdir(datadir);
end

% Laser/FB settings
current = 560e-6;
fbAmp = 0.2;
fbPhase = 0;
alpha_par = 0;
tau_fb_par = 0.8;

% feedback matrix settings
feedAmpMat = [1, 0; 0, 0];
feedPhaseMat = [1, 1; 1, 1];

% bifurcation setup
aRot=...
    [0,-1,0,0,0;...
    1,0,0,0,0;...
    0,0,0,0,0;...
    0,0,0,0,0;...
    0,0,0,0,0];
expRot = @(phi)[...
    cos(phi),-sin(phi),0,0,0; ...
    sin(phi),cos(phi),0,0,0; ...
    0,0,1,0,0; ...
    0,0,0,1,0; ...
    0,0,0,0,1];
rhs = @(x,p)nonDim_bimodalINTENSITYSystem_CnstCplRatio( ...
    x(1,1,:) + 1i*x(2,1,:), x(1,2,:) + 1i*x(2,2,:),... % Es, EsTau
    x(3,1,:), x(3,2,:),... % Iw, IwTau
    x(4,1,:), ... % rho
    x(5,1,:), ... % n
    feedPhaseMat, feedAmpMat, ...
    p(1),p(2),p(3),p(4),p(5),p(6),p(7),p(8),p(9),p(10),p(11),...
    p(12),p(13),p(14),p(15),p(16),p(17),p(18),p(19),p(20),p(21),...
    p(22),p(23),p(24),p(25),p(26),p(27),p(28),p(29)); % Leave out omega
opt_inputs = {'extra_condition',1,'print_residual_info',0};
funcs = set_rotfuncs( ...
    'sys_rhs',rhs, ... 
    'rotation',aRot, ...
    'exp_rotation',expRot, ... 
    'sys_tau',@()bimodal_sys_tau, ...
    'x_vectorized',true);

save([datadir, ...
    'generalSettings.mat'], ...
    'datadir', ...
    'current', 'fbAmp', 'fbPhase','alpha_par', 'tau_fb_par', ...
    'feedAmpMat', 'feedPhaseMat', ...
    'aRot', 'expRot', 'rhs', 'opt_inputs', 'funcs')

%% Strong dominating
% You can find this time series by sweeping up, but I am too lasy to write
% a sweep program for this system. Instead, I'm going to guess a history
% which might get me into the regime with the strong field dominating.

paramStrDom = setup_params_nonDim_CnstCplRatio(...
    'save',0, ...
    'J', current, ...
    'feed_ampli',fbAmp, ...
    'feed_ampliMatrix', feedAmpMat, ...
    'feed_phase',fbPhase, ...
    'feed_phaseMatrix', feedPhaseMat, ...
    'tau_fb', tau_fb_par, ...
    'alpha_par',alpha_par, ...
    'clear',0,...
    'populate_wrkspc', 0);

% Turn On solver
systemStrDom = @(x)nonDim_bimodalINTENSITYSystem_CnstCplRatio(...
    x(1,1,:) + 1i*x(2,1,:), x(1,2,:) + 1i*x(2,2,:),... % Es, EsTau
    x(3,1,:), x(3,2,:),... % Iw, IwTau
    x(4,1,:), ... % rho
    x(5,1,:), ... % n
    paramStrDom.cplPar.feed_phaseMatrix, ...
    paramStrDom.cplPar.feed_ampliMatrix, ...
    paramStrDom.values(1),paramStrDom.values(2), ...
    paramStrDom.values(3),paramStrDom.values(4), ...
    paramStrDom.values(5),paramStrDom.values(6), ...
    paramStrDom.values(7),paramStrDom.values(8), ...
    paramStrDom.values(9),paramStrDom.values(10), ...
    paramStrDom.values(11),paramStrDom.values(12), ...
    paramStrDom.values(13),paramStrDom.values(14), ...
    paramStrDom.values(15),paramStrDom.values(16), ...
    paramStrDom.values(17),paramStrDom.values(18), ...
    paramStrDom.values(19),paramStrDom.values(20), ...
    paramStrDom.values(21),paramStrDom.values(22), ...
    paramStrDom.values(23),paramStrDom.values(24), ...
    paramStrDom.values(25),paramStrDom.values(26), ...
    paramStrDom.values(27),paramStrDom.values(28), ...
    paramStrDom.values(29)); % Leave out omega

lags = paramStrDom.values(paramStrDom.tau_fb.index);
hist = [0.9^2, 0, 0.01, 0.6, 14];
timeSpan = [0, 15];

timeSeriesStrDom = dde23( ...
    @(t,y,z)systemStrDom([y,z]),...
    lags,hist,timeSpan,ddeset('RelTol',10^-8)); % , 'OutputFcn', @odeplot

%% Strong dominating, Bifurcation
% Now we will use the time series from above to explore the bifurcations in
% the strong dominating case.
branch_length = 120;

stepBoundStrDom = {'step',0.009, ...
    'max_step', ...
    [paramStrDom.feed_ampli.index,0.006, ...
    paramStrDom.omega1.index,0.1], ...
    'newton_max_iterations',10, ...
    'max_bound',[paramStrDom.feed_ampli.index,2], ...
    'min_bound', [paramStrDom.feed_ampli.index,-2], ...
    'halting_accuracy',1e-10, ...
    'minimal_accuracy',1e-8};

[branchStstStrDom,~]=SetupStst(funcs, ...
    'contpar',[paramStrDom.feed_ampli.index, paramStrDom.omega1.index], ...
    'corpar',[paramStrDom.omega1.index],...
    'x', timeSeriesStrDom.y(:,end), ...
    'parameter',paramStrDom.values(1:end-1),...
    opt_inputs{:},...
    stepBoundStrDom{:});

% calculate
[branchStstStrDom,~,~,~] = br_contn(funcs,branchStstStrDom,branch_length);
branchStstStrDom = br_rvers(branchStstStrDom);
[branchStstStrDom,~,~,~] = br_contn(funcs,branchStstStrDom,round(branch_length/6));

% stability analysis
[branchStstStrDom.nunst,~,~,branchStstStrDom.point] = GetRotStability(...
    branchStstStrDom, ...
    funcs, 1);
branchStstStrDom.indFold = find(abs(diff(branchStstStrDom.nunst))==1);
branchStstStrDom.indHopf = find(abs(diff(branchStstStrDom.nunst))==2);
branchStstStrDom.error = 0;


% Save Strong Dom
save([datadir, ...
    'strongDom.mat'], ...
    'paramStrDom','systemStrDom','timeSeriesStrDom', ...
    'stepBoundStrDom','branchStstStrDom');


%% Strong dominating, Bifurcation Phase
% We make "cuts" along the phase direction starting with the branch above
% where we followed amplitude. The cuts are at 2/6th, 3/6th, 4/6th, and
% 5/6th the point number of the amplitude branch.

% create container for phase stst branches
numPhaseBranches = 32;
pts4PhaseBranch = round( ...
    numel(branchStstStrDom.point)/(numPhaseBranches+2) * ( (1:numPhaseBranches) + 1) );
branch_length = 400;

branchPhaseStrDom = repmat( ...
    struct( ...
    'method', struct, ...
    'parameter', struct, ...
    'point', struct, ...
    'nunst', 0, ...
    'indFold', 0, ...
    'indHopf', 0, ...
    'error', 0),...
    [numPhaseBranches,1]);

stepBoundStrDomPhase = { ...
    'step',pi/32, ...
    'max_step', ...
    [paramStrDom.feed_phase.index,1.75*pi/32, ...
    paramStrDom.omega1.index,0.1], ...
    'newton_max_iterations',10, ...
    'max_bound',[paramStrDom.feed_phase.index,20*pi], ...
    'min_bound', [paramStrDom.feed_phase.index,-20*pi], ...
    'halting_accuracy',1e-10, ...
    'minimal_accuracy',1e-8};

for i = 1:numPhaseBranches
    [branchStstStrDomPhase,~] = SetupStst( ...
        funcs, ...
        'contpar',[paramStrDom.feed_phase.index, paramStrDom.omega1.index], ...
        'corpar',[paramStrDom.omega1.index],...
        'x', branchStstStrDom.point(pts4PhaseBranch(i)).x, ...
        'parameter',branchStstStrDom.point(pts4PhaseBranch(i)).parameter,...
        opt_inputs{:},...
        stepBoundStrDomPhase{:});

    % calculate
    [branchStstStrDomPhase,~,~,~] = br_contn(funcs,branchStstStrDomPhase,branch_length);
    branchStstStrDomPhase = br_rvers(branchStstStrDomPhase);
    [branchStstStrDomPhase,~,~,~] = br_contn(funcs,branchStstStrDomPhase,branch_length);

    % stability analysis
    [branchStstStrDomPhase.nunst,~,~,branchStstStrDomPhase.point] = GetRotStability( ...
        branchStstStrDomPhase, ...
        funcs, 1);
    branchStstStrDomPhase.indFold = find(abs(diff(branchStstStrDomPhase.nunst))==1);
    branchStstStrDomPhase.indHopf = find(abs(diff(branchStstStrDomPhase.nunst))==2);
    branchStstStrDomPhase.error = 0;
    
    % add to 
    branchPhaseStrDom(i,1) = branchStstStrDomPhase;
    
end


% Save Strong Dom
save([datadir, ...
    'strongDom.mat'], ...
    'stepBoundStrDomPhase', 'branchPhaseStrDom', ...
    '-append');


%% 3D PLOT strong dom

figure();

% for i = 1:numel(hopfPkgStrDom)
%     % select the ones that destablize the branch
%     [~,destabFold,destabHopf] = destabilize_finder(branchPhaseStrDom(i,1).nunst);
%     
%     if numel(destabHopf) ~= 0 && max(destabHopf) <= numel(hopfPkgStrDom{i})
%         disp('yep')
%         for j = destabHopf' % 1:numel(hopfPkgStrDom{i})
%             if hopfPkgStrDom{i}(j,1).error == 0
%                 plot_branch3(hopfPkgStrDom{i}(j,1), paramStrDom, ...
%                     'add_2_gcf',1, ...
%                     'color', 'cyan', ...
%                     'axes_indParam', ...
%                     {hopfPkgStrDom{i}(j,1).parameter.free(1), ...
%                     hopfPkgStrDom{i}(j,1).parameter.free(2), ...
%                     'x1'}, ...
%                     'PlotStyle', { 'LineStyle', '-', 'Marker', '.' } );
%             end
%         end
%     end
%     
%     if numel(destabFold) ~= 0 && max(destabFold) <= numel(foldPkgStrDom{i})
%         for j = destabFold' % 1:numel(foldPkgStrDom{i})
%             if foldPkgStrDom{i}(j,1).error == 0
%                 plot_branch3(foldPkgStrDom{i}(j,1), paramStrDom, ...
%                     'add_2_gcf',1, ...
%                     'color', 'r', ...
%                     'axes_indParam', ...
%                     {foldPkgStrDom{i}(j,1).parameter.free(1), ...
%                     foldPkgStrDom{i}(j,1).parameter.free(2), ...
%                     'x1'}, ...
%                     'PlotStyle', { 'LineStyle', '-', 'Marker', '.' } );
%             end
%         end
%     end
%     
% end

% find highest nunst
globalmax = 0;
for i = 1: numel(branchPhaseStrDom)
    localmax = max(branchPhaseStrDom(i,1).nunst);
    if localmax > globalmax
        globalmax = localmax;
    end
end
% for j = 1:numel(ampPkgStrDom)
%     branchAmpStrDom = ampPkgStrDom{j,1};
%     for i = 1: numel(branchAmpStrDom)
%         localmax = max(branchAmpStrDom(i,1).nunst);
%         if localmax > globalmax
%             globalmax = localmax;
%         end
%     end
% end
for i = 1: numel(branchStstStrDom)
    localmax = max(branchStstStrDom(i,1).nunst);
    if localmax > globalmax
        globalmax = localmax;
    end
end

% ribs
for i = numel(branchPhaseStrDom):-1:1
    plot_branch3(branchPhaseStrDom(i,1), paramStrDom, ...
        'nunst_color',{branchPhaseStrDom(i,1).nunst, globalmax}, ...
        'add_2_gcf',1, ...
        'axes_indParam', ...
        {paramStrDom.feed_phase.index, ...
        paramStrDom.feed_ampli.index, ...
        'x1'}, ...
        'PlotStyle', { 'LineStyle', 'None', 'Marker', '.' } );
end

% % main spine
% cutBranch = branchStstStrDom;
% cutBranch.point(1:50) = [];
% cutBranch.nunst(1:50) = [];
% 
% plot_branch3(cutBranch, paramStrDom, ...
%     'nunst_color',{cutBranch.nunst, 6}, ... % globalmax}, ...
%     'add_2_gcf',1, ...
%     'axes_indParam', ...
%     {paramStrDom.feed_phase.index, ...
%     paramStrDom.feed_ampli.index, ...
%     'x1'}, ...
%     'PlotStyle', { 'LineStyle', '-', 'Marker', '.' } );

% % extra spines
% for j = 1:numel(ampPkgStrDom)
%     
%     branchAmpStrDom = ampPkgStrDom{j,1};
%     
%     % extra spines
%     for i = 1:numel(branchAmpStrDom)
%         
%         if branchAmpStrDom(i,1).error == 1;
%             continue
%         end
%         
%         plot_branch3(branchAmpStrDom(i,1), paramWeakDom, ...
%             'nunst_color',{branchAmpStrDom(i,1).nunst, 6}, ... % globalmax}, ...
%             'add_2_gcf',1, ...
%             'axes_indParam', ...
%             {paramWeakDom.feed_phase.index, ...
%             paramWeakDom.feed_ampli.index, ...
%             'x1'}, ...
%             'PlotStyle', { 'LineStyle', 'None', 'Marker', '.' } );
%     end
% end
% 
% ylim([0,1])
% zlim([0,3])

%% Add extendRibs

for i = 19:numel(extendedRibs)
    localmax = max(extendedRibs{i,1}.nunst);
    if localmax > globalmax
        globalmax = localmax;
    end
end

% ribs
for i = 19:numel(extendedRibs)
    plot_branch3(extendedRibs{i,1}, paramStrDom, ...
        'nunst_color',{extendedRibs{i,1}.nunst, globalmax}, ...
        'add_2_gcf',1, ...
        'axes_indParam', ...
        {paramStrDom.feed_phase.index, ...
        paramStrDom.feed_ampli.index, ...
        'x1'}, ...
        'PlotStyle', { 'LineStyle', 'None', 'Marker', '.' } );
end